/*
© [2022] Microchip Technology Inc. and its subsidiaries.

    Subject to your compliance with these terms, you may use Microchip 
    software and any derivatives exclusively with Microchip products. 
    You are responsible for complying with 3rd party license terms  
    applicable to your use of 3rd party software (including open source  
    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
    THIS SOFTWARE.
*/

#include "mcc_generated_files/system/system.h"
#include "application.h"

#define SET (1)
#define CLEAR (0)
#define DIFFERENTIAL (1)
#define SINGLE_ENDED (0)
#define START_OF_FRAME (0x5F)
#define END_OF_FRAME (0xA0)

volatile uint8_t timer0OverFlow = CLEAR;
volatile uint8_t adccConversionDone = CLEAR;
volatile uint8_t switchPressed = CLEAR;
uint8_t LUT_pointsCounter = NO_OF_POINTS; // Gives the count of points in LUT
const uint8_t *LUT_ptr; // Pointer to feed the input to DAC1

// Lookup Table to generate triangular wave 
const uint8_t triangleLUT[NO_OF_POINTS] = {
    0x4, 0x8, 0xc, 0x10, 0x14, 0x18, 0x1c, 0x20,
    0x24, 0x28, 0x2c, 0x30, 0x34, 0x38, 0x3c, 0x40,
    0x44, 0x48, 0x4c, 0x50, 0x54, 0x58, 0x5c, 0x60,
    0x64, 0x68, 0x6c, 0x70, 0x74, 0x78, 0x7c, 0x80,
    0x83, 0x87, 0x8b, 0x8f, 0x93, 0x97, 0x9b, 0x9f,
    0xa3, 0xa7, 0xab, 0xaf, 0xb3, 0xb7, 0xbb, 0xbf,
    0xc3, 0xc7, 0xcb, 0xcf, 0xd3, 0xd7, 0xdb, 0xdf,
    0xe3, 0xe7, 0xeb, 0xef, 0xf3, 0xf7, 0xfb, 0xff,
    0xfb, 0xf7, 0xf3, 0xef, 0xeb, 0xe7, 0xe3, 0xdf,
    0xdb, 0xd7, 0xd3, 0xcf, 0xcb, 0xc7, 0xc3, 0xbf,
    0xbb, 0xb7, 0xb3, 0xaf, 0xab, 0xa7, 0xa3, 0x9f,
    0x9b, 0x97, 0x93, 0x8f, 0x8b, 0x87, 0x83, 0x80,
    0x7c, 0x78, 0x74, 0x70, 0x6c, 0x68, 0x64, 0x60,
    0x5c, 0x58, 0x54, 0x50, 0x4c, 0x48, 0x44, 0x40,
    0x3c, 0x38, 0x34, 0x30, 0x2c, 0x28, 0x24, 0x20,
    0x1c, 0x18, 0x14, 0x10, 0xc, 0x8, 0x4, 0x4
};

/*
  @Description
   This functions checks if switch is pressed and calls the switching routine to select between ADCC modes.
   Calls the routine to update DAC register upon Timer0 overflow.
   Sends the ADCC converted result to terminal in graphical format upon ADCC conversion.
  @Preconditions
    None
  @Param
    None
  @Returns
    None      
 */
void Application(void) 
{
    if (switchPressed == SET) 
    {
        switchPressed = CLEAR;
        LED0_Toggle();
        ChangeADCCMode();
    }

    if (timer0OverFlow == SET) 
    {
        timer0OverFlow = CLEAR;
        UpdateDac();
    }

    if (adccConversionDone == SET) 
    {
        adccConversionDone = CLEAR;
        while(!(UART1.IsTxReady()));
        UART1.Write(START_OF_FRAME);                                            
        while(!(UART1.IsTxReady()));
        UART1.Write(ADFLTRL);                                          
        while(!(UART1.IsTxReady()));
        UART1.Write(ADFLTRH);                                               
        while(!(UART1.IsTxReady()));
        UART1.Write(END_OF_FRAME);      
    }
}

/*
  @Description
   This function configures ADCC in two modes , single-ended and differential, alternatively with switch press.
   In single ended mode, ADCC input is the triangular wave generated by DAC1 and amplified by OPA.
   In differential mode, ADCC input is the differential voltage of triangular wave  and the offset 
   voltage of 1.024V provided by DAC2.
  @Preconditions
    None
  @Param
    None
  @Returns
    None      
 */ 
void ChangeADCCMode(void) 
{ 
    if (ADCON0bits.IC == DIFFERENTIAL) 
    {
        ADCON0bits.IC = SINGLE_ENDED;   
    } 
    else 
    {
        ADCON0bits.IC = DIFFERENTIAL; 
    }
    
    LUT_ptr = triangleLUT;
    LUT_pointsCounter = NO_OF_POINTS;  
}

/*
  @Description
   Changes the DAC register periodically with Timer0 overflow to generate a triangular wave.
   DAC register is updated with values from Lookup Table 'triangleLUT',ranging from 0-255 and back to zero,
   incrementing by 4 points to complete one cycle of wave. 
   Frequency of the generated signal = 1/ (total number of points in one cycle * Timer0 period) 
   1Hz Triangular wave is generated with 128 points and Timer0 period = 7.8 msec
  @Preconditions
    None
  @Param
    None
  @Returns
    None      
 */
void UpdateDac(void) 
{  
    DAC1_SetOutput(*(LUT_ptr++));
    LUT_pointsCounter--;
    if (LUT_pointsCounter <= 0)
    {
        LUT_pointsCounter = NO_OF_POINTS;
        LUT_ptr = triangleLUT;
    }
}

/*
  @Description
    Interrupt handler routine for Timer0 overflow.
  @Preconditions
    None
  @Param
    None
  @Returns
    None      
 */
void TMR0_UserInterruptHandler(void) 
{
    timer0OverFlow = SET;
}

/*
  @Description
    Interrupt handler routine for ADCC conversion upon Threshold interrupt.
    ADCC is auto-triggered by TImer2 every 2ms.
  @Preconditions
    None
  @Param
    None
  @Returns
    None      
 */
void ADCC_UserThresholdInterruptHandler(void) 
{
    adccConversionDone = SET;
}

/*
  @Description
    Interrupt handler routine for Timer4 overflow.
    Interrupt occurs on switch press.
  @Preconditions
    None
  @Param
    None
  @Returns
    None      
 */
void TMR4_UserInterruptHandler(void) 
{
    switchPressed = SET;
}